#pragma config(Sensor, S2,     soundSensor,         sensorSoundDB)
#pragma config(Sensor, S4,     sonarSensor,         sensorSONAR)
#pragma config(Sensor, S1,     HTCS2,               sensorLowSpeed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Include a link to the i2c header files for the color sensor
#include "drivers/common.h"
#include "drivers/HTCS2-driver.h"

//Variable Declarations
int rowColor = 12;
int _rowColor;

const int BLUE = 2;
const int RED = 10;
const int GREEN = 3;
const int BLACK = 17;
const int ORANGE = 7;


//Now includes Orange, Black, Red, Blue, and Green
void sayColor(int color){
  switch(color){

  case 2:   PlaySoundFile("Blue.rso");     break;

  case 3:   PlaySoundFile("Green.rso");    break;

  case 7:   PlaySoundFile("Orange.rso");   break;

  case 10:   PlaySoundFile("Red.rso");     break;

  case 17:  PlaySoundFile("Black.rso");    break;
  }
}
//Stops the robot
void stop()
{
  motor[motorB] = 0;
	motor[motorC] = 0;
}
//Checks for the color
void checkColor()
{
  if(HTCS2readColor(HTCS2) == BLUE){
       rowColor = BLUE;
       stop();
    }

    if(HTCS2readColor(HTCS2) == GREEN){
       rowColor = GREEN;
    }

    if(HTCS2readColor(HTCS2) == RED){
       rowColor = RED;
    }

    if(HTCS2readColor(HTCS2) == BLACK){
       rowColor = BLACK;
    }

    if(HTCS2readColor(HTCS2) == ORANGE){
       rowColor = ORANGE;
    }

    sayColor(HTCS2readColor(HTCS2));
    wait1Msec(1000);
}
//Searches for an object. If there is an object within about 2", stops, then checks for the color given by the parameter. Plays brilliant if color is found.
void searchForObject(int color)
{
      motor[motorB] = 10;
	    motor[motorC] = 10;

  if(SensorValue(sonarSensor) < 10)
  {
    stop();
    checkColor();
    if(HTCS2readColor(HTCS2) == color)
    {
      PlaySoundFile("Brilliant.rso");
    }
  }
}


task main()
{


  //RobotC3
  //Notes to Sedrick: This works on RobotC3 all the time and only says it once (as long as it is moved away within 1 second, if it is not, the robot will repeat the color).
  //However, RobotC3 crashed and I had to switch to RobotC1.
  //
  //RobotC1
  //reads all colors (most of the time) except red.
  //RobotC1 will read red sometimes, problem is, it also reads red as orange.
  //Also, RobotC1 also tends to not recognize Black (sometimes).
  //sonarSensor on RobotC1 does not appear to work (could just be I'm not doing something right)
  //
  //RobotC2
  //Color sensor is working perfectly at the moment. Black has to be about 3/4 inches away before it is read. Others can be further away.
  //Cannot get this ultrasonic sensor to work either.
  //
  //On another note, 1 inch away seems to be the best time to read the color, so we need to get the sonar to move us to about 1 inch away.

  while(true)
  {
    searchForObject(2);
    /*
    //The sonarSensor (This part may or may not work, I have no idea. I cannot get the sensor to work.)
    do
	  {
	    motor[motorB] = 10;
	    motor[motorC] = 10;
	  }
    //changed to 40; robot gets closer to object to read the color -SS
    while(SensorValue(sonarSensor) > 38);


    //This part deals with the color
    nxtDisplayCenteredTextLine(3, "Color: " + HTCS2readColor(HTCS2));

    if(HTCS2readColor(HTCS2) == BLUE){
       rowColor = BLUE;
       stop();
    }

    if(HTCS2readColor(HTCS2) == GREEN){
       rowColor = GREEN;
    }

    if(HTCS2readColor(HTCS2) == RED){
       rowColor = RED;
    }

    if(HTCS2readColor(HTCS2) == BLACK){
       rowColor = BLACK;
    }

    if(HTCS2readColor(HTCS2) == ORANGE){
       rowColor = ORANGE;
    }

    sayColor(HTCS2readColor(HTCS2));
    wait1Msec(1000);
    */
  }


}
